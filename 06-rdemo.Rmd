---
  bookdown::gitbook:
    config:
      toc:
        collapse: null
      edit: null
      download: null
---

# GIS operations in R {#rdemo}

## Case study and demo datasets {#casestudy}
Ok, for demonstrating some of the many GIS operations R can perform we will be using data from one of my favourite study areas, the Cape Peninsula.

The datasets we will use, some of their properties and where to source them are tabled below:

<br>

```{r datasets, echo = F, warning=F, message=F}
library(knitr) 

datasets <- data.frame(
  `Name` = c("Localities", "Watercourses", "Vegetation Types", "Elevation"),
  `Data model` = c("Vector", "Vector", "Vector", "Raster"),
  `Geometry type` = c("Point", "Line", "Polygon", "Raster"),
  `File format` = c("", "ESRI shapefile", "ESRI shapefile", "GeoTIFF"),
  `Data source` = c("iNaturalist", "City of Cape Town", "City of Cape Town", "City of Cape Town"),
  URL = c("https://www.inaturalist.org/", "https://odp-cctegis.opendata.arcgis.com/datasets/open-watercourse", "https://odp-cctegis.opendata.arcgis.com/datasets/indigenous-vegetation-current-extent", "https://odp-cctegis.opendata.arcgis.com/datasets/digital-elevation-model-10m-grid-general-binary-ascii")
)

kable(datasets)
```

<br>

If you'd like to follow along and run the analyses that follow, please follow the links and download the datasets. Please note that the elevation dataset is ~130MB. I'll also put a copy of all datasets on the Vula site for the course, which I understand is zero-data rated.

<br>

## Working with vector data

### Reading and writing

_sf_ has a one-size-fits-all approach in that most functions can be applied to most different data types (point, line, polygon, etc) or, in the case of reading and writing, file formats. To read data the function you want is `st_read()`. 

You'll note that most of the _sf_ functions begin with "st_" - this stands for "spatial and temporal" and is the same in some other GIS like PostGIS.

Let's try to read in some dat with `st_read()`:

> Note that if you're trying any of the read/write code at home, you'll need to set the file path to where you put the data and want the outputs on your local machine. You can also use `?setwd` to simplify this.

<br>

```{r}
library(sf)

veg <- st_read("data/cape_peninsula/veg/Vegetation_Indigenous.shp")
```

This has successfully read in the data and given us a summary of some of its properties. Note the projection (proj4string). This is Transverse Mercator Lo19 (i.e. centred on the 19 degree line of longitude), which has a unit in metres (see the bounding box coordinates). It's a good projection for most calculations at this scale (and on this line of longitude*).

>*If you're using Transverse Mercator, always make sure it is set for your closest "odd" line of longitude (i.e. Lo19, Lo21, Lo23)!

<br>

Let's have a closer look at the data:

```{r}
class(veg)
```

It is an object of two different "classes", a `data.frame`, which is an R object class you should be familiar with, and class `sf`, which is the native class for the _sf_ library.

The nice thing about being both classes is it means you can apply the functions built for either class, e.g.

```{r}
head(veg)
```

This is a commonly used function for looking at the first few rows of a dataframe. Note there are 5 attribute columns and a 6th `geometry` column. All _sf_ objects have a geometry column. This is where it stores the geometry - i.e. the point, line, polygon etc - associated with each row of attribute data.

<br>

To write data with _sf_ you use `st_write()`, like so:

```{r}
st_write(veg, "data/cape_peninsula/veg/Vegetation_Indigenous_duplicate.shp")
```

```{r}
file.exists("data/cape_peninsula/veg/Vegetation_Indigenous_duplicate.shp") # Just to confirm for you that the file exists
```

```{r, echo = F}
unlink("data/cape_peninsula/veg/Vegetation_Indigenous_duplicate*") # Deletes the file
```

Note that the function recognised that I wanted to write out an ESRI shapefile from the `.shp` file extension I provided. You can set the file type using the `driver =` setting in `st_write()`. Try `st_drivers()` for the list of file types supported.

<br>

### Basic plotting

As with other data types in R (and perhaps even more so with spatial data), you can really go to town with plotting. I'm only going to show you enough to be able to interrogate your data. Making it look pretty is a week-long course or more in its own right. Check out the _"Making maps with R"_ chapter in Lovelace et al's online book [Geocomputation with R](https://geocompr.robinlovelace.net/) for a good start.

<br>

The easiest way to plot datasets in R is often a bad thing to do when working with spatial datasets!

```{r}
plot(veg)
```

Fortunately, in this case the dataset isn't too big, but often you'll either be overwhelmed with plots or your computer will crash...

Why 5 plots and not one? This is because _sf_ wants to plot the properties of each attribute in the attribute table. Fortunately, there were only 5, but there could have been hundreds! You can select the one you want with indexing like so:

```{r}
plot(veg[3])
```

These are the National Vegetation Types for the City of Cape Town municipality.

You'll note that we're using the base R graphics functions. I mentioned before that _sf_ integrates well with the [_Tidyverse_](https://www.tidyverse.org/), so this could also be plotted like so:

```{r}
library(tidyverse) #calls ggplot2 and other Tidyverse packages together

ggplot() +
  geom_sf(data=veg, aes(fill = `National_`))
```

That's better for the legend, but now we've squashed the map. Let's narrow in on the Cape Peninsula for convenience.

<br>

### Cropping

Here we'll apply the function `st_crop`. To use the function you need an object to crop, and an extent or bounding box to crop to. **_sf_** is clever, and you can set the extent by giving it another object who's extent you'd like to match (check the bounding box given when we read in the data earlier). 

We don't have a second object in this case, so we have to provide a "numeric vector with named elements xmin, ymin, xmax and ymax", like so:

```{r}
ext <- c(-66642.18, -3809853.29, -44412.18, -3750723.29) #Coordinates in metres according to TM Lo19

ext

names(ext) <- c("xmin", "ymin", "xmax", "ymax") #Give it names

ext
```

Now we can feed that into `st_crop`

```{r}
veg <- st_crop(veg, ext) #Note that I'm overwriting the old data object

ggplot() + geom_sf(data=veg, aes(fill = `National_`))
```

Better?

But what about the silly splits like _Peninsula Granite Fynbos - North/South_ and _Cape Flats Dune Strandveld - West Coast/False Bay_. 

Which ones do I mean? 

<br>

### Select and subset by attribute

Let's select them from the attribute table and plot them.

```{r}
#Get a list of the veg types we want
split_veg <- c("Peninsula Granite Fynbos - North", 
               "Peninsula Granite Fynbos - South", 
               "Cape Flats Dune Strandveld - West Coast", 
               "Cape Flats Dune Strandveld - False Bay")

#Use base R indexing to select attributes
vegsub <- veg[which(veg$National_ %in% split_veg),]

#Plot
ggplot() + geom_sf(data=vegsub, aes(fill = `National_`))
```

Or tidyverse...

```{r}
#Using tidyverse piping to filter and plot
veg %>% 
  filter(National_ %in% split_veg) %>%
  ggplot() +
  geom_sf(aes(fill = `National_`))
```

Ok. What if we decided we don't want them split?


### Combine classes and dissolve by attribute

We can just rename them in appropriate column in the attribute table...

```{r}
vegsub$National_ <- str_replace_all(vegsub$National_, c("Peninsula Granite Fynbos - North" = "Peninsula Granite Fynbos", 
               "Peninsula Granite Fynbos - South" = "Peninsula Granite Fynbos", 
               "Cape Flats Dune Strandveld - West Coast" = "Cape Flats Dune Strandveld", 
               "Cape Flats Dune Strandveld - False Bay" = "Cape Flats Dune Strandveld"))

ggplot() + geom_sf(data=vegsub, aes(fill = `National_`))
```

But from the polygon boundaries we see that there are a number of adjacent polygons (i.e. they have shared boundaries) that are of the same veg type. We can "dissolve" these boundaries like so:

```{r}
vs_dissolve <- vegsub %>% group_by(National_) %>% summarize() 

#plot dissolved
ggplot() + geom_sf(data=vs_dissolve, aes(fill = National_))
```

Ok... I think we've flogged that horse as far as it'll go for now. Let's bring in another dataset. How about points?

### Calling iNaturalist data from R {#getinat}

A very cool feature of [iNaturalist](https://www.inaturalist.org/) is that the team at [rOpenSci](https://ropensci.org/) have built a great R package for interfacing with it directly, called [_rinat!_](https://docs.ropensci.org/rinat/)

Let's get all the records we can for the King Protea (*Protea cynaroides*).

```{r}
library(rinat)

#Call the data directly from iNat
pc <- get_inat_obs(taxon_name = "Protea cynaroides",
                   bounds = c(-34.5, 18, -33.5, 18.5),
                   maxresults = 1000)

#Filter returned observations by a range of attribute criteria
pc <- pc %>% filter(positional_accuracy<46 & 
                latitude<0 &
                !is.na(latitude) &
                captive_cultivated == "false" &
                quality_grade == "research")

#Make the dataframe a spatial object of class = "sf"
pc <- st_as_sf(pc, coords = c("longitude", "latitude"), crs = 4326) #Note that I had to define the CRS!!!

#Plot
ggplot() + geom_sf(data=pc)
```

<br>

Great! We got lots of points, but without a base layer its very difficult to tell where exactly these are?

<br>

### Adding basemaps to plots

Let's pull up a base layer from Open Street Maps and plot our points on that.

<br>

```{r}
library(rosm)
library(ggspatial)

ggplot() + 
  annotation_map_tile(type = "osm", progress = "none") + 
  geom_sf(data=pc)
```

<br>

Note that there are quite a few base layer options that can be set with `type = ""`. Try `rosm::osm.types()` to see them all.

This is better than nothing, but the scale of the map is too small to really see where the plants actually are. It would be much easier if we could look at the data interactively?

<br>

### Interactive maps with _leaflet_

We can generate interactive maps by calling the [leaflet](https://leafletjs.com/) mapserver using wrapper functions in the [leaflet R package](https://rstudio.github.io/leaflet/) written for this purpose.

<br>

```{r}
library(leaflet)
library(htmltools)
leaflet() %>%
  addTiles(group = "Default") %>%  # Add default OpenStreetMap map tiles

#  addPolygons(data=layer, color = "#999999", weight = 1, smoothFactor = 0.5, opacity = 0.75, fillOpacity = 0.15, highlightOptions = highlightOptions(color = "white", weight = 2, bringToFront = F), label=~layer$QUARTERN, group = "Quaternaries") %>%
  
  addCircleMarkers(data = pc,
                   group = "Protea cynaroides",
                   radius = 3, 
                   color = "green") 
```

<br>

Much better!

Strange, but even though we filtered our iNaturalist records for `captive_cultivated == "false"` we still have a number of observations that appear to be in people's gardens. **_Let this serve as a warning to be wary of all data! Always do "common-sense-checks" on your data and the outputs of your analyses!!!_**

<br>

### Intersecting points and polygons

One way to drastically reduce the number of cultivated records is to overlay the localities (points) with the _remaining extent_ of the vegetation types.

<br>

```{r}

vegr <- st_read("data/cape_peninsula/veg/Vegetation_Indigenous_Remnants.shp")

#st_join
#st_intersects
#st_intersection
```

